# 동적 계획법 (DP)

## 동적계획법이란?
- 복잡한 문제를 여러 개의 간단한 문제로 분리
- 부분의 문제들을 해결함으로써 최종적으로 복잡한 문제의 답을 구하는 방법
- `피보나치 수열`의 원리가 결국은 동적 계획법

## 동적 계획법의 핵심 이론
1. 큰 문제를 작은 문제로 **나눌 수 있어야 한다.**
2. 작은 문제들이 반복돼 나타나고 사용되며 이 **작은 문제들의 결괏값은 항상 같아야 한다.**
3. 모든 작은 문제들은 **한 번만 계산해 DP 테이블에 저장**하며 추후 재사용할 때는 이 DP 테이블을 이용한다. (메모제이션 기법)
4. 동적계획법은 **톱-다운방식**과 **바텀-업 방식**으로 구현할 수 있다.

## 피보나치 수열 예제
```text
D[N] = D[N - 1] + D[N - 2]
```
### 1. 동적 계획법으로 풀 수 있는지 확인
- 문제를 작은 문제로 나눌 수 있는가? ✅
  - D[5] = D[4] + D[3]
- 작은 문제의 결과값이 항상 동일한가? ✅
  - D[3]은 항상 동일

### 2. 점화식 세우기
- 문제를 나눈 후, 전체 문제와 부분 문제 간의 인과관계 파악
  - D[N] = D[N - 1] + D[N - 2]

### 3. 메모제이션 원리 이해하기
- 부분 문제를 풀었을 때 이 문제를 DP 테이블에 저장
- 다음에 같은 문제가 나왔을 때 계산하지 않고 DP 테이블의 값을 이용
```java
// DP 테이블 정의 및 초기화
D = new int[n+1];
for (int i=0; i<=n; i++){
    D[i] = -1;
}
D[0] = 0;
D[1] = 1;
```

### 4. 톱-다운 구현 방식 이해하기
- 위에서부터 문제를 파악해 내려오는 방식
- 재귀함수 활용
- 가독성 높고, 이해가 직관적
```java
fibo(n);

static int fibo(int n){
    if (D[n] != -1) // 기존에 계산한 적이 있는 부분의 문제는 재계산하지 않고 리턴
        return D[n];
    return D[n] = fibo(n-2) + fibo(n-1);
}
```

### 5. 바텀-업 구현 방식 이해하기
- 가장 작은 부분 문제부터 해결하면서 점점 큰 문제로 확장
- 반복문 형태로 구현
```java
for (int i=2; i<=n; i++){
    D[i] = D[i-1]+D[i-2];
}
```

## 톱-다운 vs 바텀-업
- 좀 더 안전한 방법은 바텀-업
- 톱-다운 방식은 재귀 함수 형태로 구현되어 있기 때문에 재귀의 깊이가 매우 깊어질 경우 런타임 에러가 발생할 수 있음
- 하지만 실제로는 이 부분까지 고려해야 할 난이도는 잘 나오지 않음.
- 본인에게 편한 방식으로 구현하면 됨.