# 백트래킹

## 백트래킹이란?
1. **재귀적**으로 **문제를 하나씩 풀어가면서** 
2. 현재 재귀를 통해 확인 중인 노드(상태)가 제한된 조건에 위배되는지 판단하고, 
3. **만약 해당 노드가 제한된 조건을 위배한다면 그 노드를 제외하고 다음 단계로 나아가는 방식**

<U>**가장 중요한 점은 제한조건을 위배한다면 그 노드를 제외한다는 점이다.**</U>
여기서 더 이상 탐색할 필요가 없는 상태를 제외하는 것을 가지치기(pruning)라고도 한다.

### 코드 포인트 몇 가지
1. 방문처리 했다가 재귀 끝나고 다서 방문처리 해제한다.
```java
visit[i] = true;		// 해당 노드를 방문상태로 변경
arr[depth] = i + 1;		// 해당 깊이를 index로 하여 i + 1 값 저장
backtracking(N, M, depth + 1);	// 다음 자식 노드 방문을 위해 depth 1 증가시키면서 재귀호출

// 자식노드 방문이 끝나고 돌아오면 방문노드를 방문하지 않은 상태로 변경
visit[i] = false;'
```
2. 매개변수로 depth를 가지며, 목표 수가 되면 반환하여 재귀를 종료한다.
```java
public static void BT(int depth) {
    if (depth == M) {
        // 결과 처리
        return;
    }
```


## 브루트포스 vs 백트래킹 vs DFS
" a + b + c + d = 20 을 만족하는 두 수를 모두 찾아내시오. ( 0 ≤ a ,b ,c ,d < 100) "

- **브루트포스**는 말 그대로 <U>'모든 경우의 수'를 찾아보는 것</U>이다. 
  - 즉, a = 1, b = 1, c =1, d = 1 부터 시작하여 a = 100, b = 100, c = 100, d = 100 까지 총 1억개의 경우의 수를 모두 찾아보면서 a + b + c + d = 20 이 만족하는 값을 탐색하는 것이다.
  - 브루트포스가 강력한 점은 모든 경우의 수를 탐색하다보니 만족하는 값을 100% 찾아낸다는 점이다.
  - 반대로 단점이라면 모든 경우의 수를 판단하는 만큼 조합 가능한 경우의 수가 많으면 많을 수록 자원을 매우 많이 필요로 한다는 점이다.

- **백트래킹**은 <U>해당 범위 내에서 **조건을 추가**하여 값의 유망성을 판단</U>한다는 의미이다.
  - 하나라도 a = 21 또는 b = 21 또는 c = 21 또는 d = 21 일 경우 20일 가능성이 1 ~ 100 범위 내에서는 절대 불가능하다. 그렇기 때문에 a > 20 이거나 b > 20, c > 20, d > 20 일 경우는 탐색하지 않는다. 그렇게 된다면 탐색하는데 필요한 자원을 많이 줄일 수 있다.
- 
- **DFS(깊이우선탐색)**은 <U>트리순회</U>의 한 형태다.
  - 즉, **백트래킹 = DFS가 아니라 백트래킹의 방법 중 하나가 DFS인 것이다.**
